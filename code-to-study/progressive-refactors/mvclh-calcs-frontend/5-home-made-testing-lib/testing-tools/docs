Docs for our home-made testing suite.

Works well for pure functions, not so well for objects.  Can you figure out why?

This project is an example of "functional oop".  
-----------------------------------
unit-test.js

requires: nothing
exports: unit_test function 
behavior: defines the unit test function and exports it

unit_test: function
	args: 3
		testee: function
			- the function to be tested
		args: array #
			- the args property from a single test_case_object 
		expected: (depends on return value of testee)
			- the expected property from a single test_case_object 
	returns: array size 2
		boolean: indicating pass or fail
		result: the result of running the unit test with the given args
	behavior:  takes in a function, arguments, and the expected output.  runs the function with the arguments and compares it to the expected output.  returns an array containing the success/failure of the test, and the actual return value for the tested function/args pair

-----------------------------------
unit-runner.js

requires: nothing
exports: unit_runner function
behavior: defines the unit_runner function and exports it

unit_runner: function
	args: 3
		test: unit_test function
		testee: function to test
		cases: array of test cases #
	return: array of unit_test result arrays 
		- see return results for unit_test
	behavior: declares an empty array, then tests the 'testee' function with each test case.  for every test case it pushes the result into the array. when all test cases have been run it returns the array of results



-----------------------------------
result-interpreter.js

requires: nothing
exports: result_interpreter function
behavior: defines result_interpreter and exports it

result_interpreter: function
	args: 2
		test_results: the return value of unit_runner
		test_cases: the test cases array used to generate test_results #
	return: array of strings
		- the array contains human-friendly strings to tell the user the result of each test case
	behavior:  takes in the results and the test cases.  it builds a human-friendly string for each test case using information contained in the test_case object.  It either generates a PASS or FAIL string, then pushes the string.  when all cases have been parsed it returns the array of strings


-----------------------------------
index.js

requires: 
	unit-test, unit-runner & result interpreter functions
exports:
	testing_module object
behavior:
	adds the 3 imported functions as properties in a new testing_module object.
	defines a new "test" function into the new object. 
	exports the testing_module object 

Testing_Module: Object
	Properties: 0
	Methods: 4
		unit_test: function - see above
		unit_runner: function - see above
		result_interpreter: function - see above
		test: function
			args: 2
				testee: function
					- the function to be tested
				cases: a test-cases array #
					- user-defined test cases
			returns: array of strings
				- the array contains human-friendly interpretations of the test results
			behavior: this is the function users use directly.  it takes in a function to test and properly formatted test cases.  it passes the function and cases through unit_test (using this.unit_runner), then returns the array generated by this.result_interpreter.


# --- # --- # --- # --- # --- #


# Array:  Test-case Objects 
	Test-case Object: 
		Properties: 3
			args: array
				- types and size of array is determined by the function being tested
			expected: (variable type)
				- must match the return type of the function being tested
			name: string
				- used to identify the test case in the terminal
			purpose: so the test cases can be run by this testing suite

# Example:
	let addition_cases = [
		{ args: [3, 3], expected: 6, name: '+/+' },
		{ args: [-3, -3], expected: -6, name: '-/-' },
		{ args: [3, -3], expected: 0, name: '+/-' },
		{ args: [-3, 3], expected: 0, name: '-/+' },
		{ args: [3, 0], expected: 3, name: 'non-0/0' },
		{ args: [0, 3], expected: 3, name: '0/non-0' }
	]